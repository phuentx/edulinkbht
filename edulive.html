<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Edulinki Meet - Blur & Menu</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Google+Sans:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
    
    <style>
        :root {
            --bg-dark: #121212;
            --surface: #1e1e1e;
            --surface-light: #2c2c2c;
            --primary: #8ab4f8; 
            --danger: #ff5252;
            --text-main: #ffffff;
            --text-muted: #9aa0a6;
            --glass-bg: rgba(30, 30, 30, 0.95);
            --border: rgba(255, 255, 255, 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- HEADER --- */
        header {
            position: fixed; top: 0; left: 0; width: 100%; height: 60px;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 24px; z-index: 50;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: none;
        }
        .header-left { display: flex; align-items: center; gap: 12px; pointer-events: auto; }
        .logo { font-family: 'Google Sans'; font-size: 19px; font-weight: 500; color: white; display: flex; align-items: center; gap: 8px;}
        .room-badge {
            background: rgba(255,255,255,0.1); backdrop-filter: blur(8px);
            padding: 6px 14px; border-radius: 20px; font-size: 13px; font-weight: 500;
            display: none; pointer-events: auto; border: 1px solid var(--border);
        }

        /* --- LOBBY --- */
        #lobby {
            position: absolute; inset: 0; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }
        .lobby-card {
            background: var(--surface); padding: 40px; border-radius: 24px;
            width: 90%; max-width: 400px; text-align: center;
            border: 1px solid var(--border);
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        }
        .lobby-card h1 { font-family: 'Google Sans'; margin-bottom: 12px; font-weight: 400; font-size: 26px; }
        .input-box {
            background: var(--surface-light); border: 1px solid transparent;
            width: 100%; padding: 16px; border-radius: 12px; color: white;
            font-size: 16px; margin: 24px 0; outline: none; transition: 0.2s;
        }
        .input-box:focus { border-color: var(--primary); background: #333; }
        .btn-primary {
            width: 100%; padding: 16px; background: var(--primary); color: #000;
            border: none; border-radius: 12px; font-weight: 600; font-size: 16px;
            cursor: pointer; margin-bottom: 12px; transition: opacity 0.2s;
        }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-text { background: none; border: none; color: var(--primary); cursor: pointer; font-weight: 500; }

        /* --- STAGE (VIDEO GRID) --- */
        #meeting-stage {
            flex: 1; display: none; position: relative;
            padding: 70px 20px 100px 20px; overflow: hidden;
            transition: margin-right 0.3s ease;
        }
        #meeting-stage.drawer-open { margin-right: 340px; }
        @media(max-width: 800px) { 
            #meeting-stage { padding: 60px 10px 90px 10px; }
            #meeting-stage.drawer-open { margin-right: 0; } 
        }

        #video-grid {
            width: 100%; height: 100%;
            display: flex; flex-wrap: wrap; justify-content: center; align-content: center; align-items: center; gap: 16px;
        }

        /* --- VIDEO CARD --- */
        .vid-card {
            position: relative; background: #202124; border-radius: 16px; overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); border: 2px solid transparent;
        }
        .vid-card.speaking { border-color: var(--primary); box-shadow: 0 0 15px rgba(138, 180, 248, 0.3); }

        video, canvas { width: 100%; height: 100%; object-fit: cover; background: #000; }
        .mirrored { transform: scaleX(-1); }

        .name-tag {
            position: absolute; bottom: 12px; left: 12px;
            background: rgba(0,0,0,0.7); padding: 4px 10px; border-radius: 6px;
            font-size: 12px; color: white; display: flex; align-items: center; gap: 6px;
            backdrop-filter: blur(4px); pointer-events: none; font-weight: 500; z-index: 2;
        }
        
        .status-icon { color: var(--danger); display: none; }
        .vid-card.muted .status-icon { display: block; }
        
        .avatar {
            position: absolute; inset: 0; background: #333; z-index: 1;
            display: none; align-items: center; justify-content: center;
            font-size: 48px; color: white; font-weight: bold;
        }
        .vid-card.cam-off video, .vid-card.cam-off canvas { opacity: 0; }
        .vid-card.cam-off .avatar { display: flex; }

        .hand-badge {
            position: absolute; top: 12px; left: 12px; z-index: 5;
            background: #2c2c2c; padding: 8px; border-radius: 50%;
            display: none; animation: pop 0.4s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .vid-card.hand-up .hand-badge { display: block; }

        /* --- CARD MORE MENU (User specific) --- */
        .card-menu-btn {
            position: absolute; top: 12px; right: 12px; z-index: 10;
            background: rgba(0,0,0,0.5); border: none; border-radius: 50%;
            width: 32px; height: 32px; color: white; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px); transition: 0.2s; opacity: 0;
        }
        .vid-card:hover .card-menu-btn, .card-menu-btn.active { opacity: 1; }
        .card-menu-btn:hover { background: rgba(0,0,0,0.8); }

        .card-dropdown {
            position: absolute; top: 50px; right: 12px; z-index: 20;
            background: var(--surface-light); border: 1px solid var(--border);
            border-radius: 8px; padding: 5px; width: 160px;
            display: none; flex-direction: column; box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        .card-dropdown.show { display: flex; }
        .card-option {
            background: none; border: none; color: white; padding: 10px; text-align: left;
            border-radius: 4px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px;
        }
        .card-option:hover { background: rgba(255,255,255,0.1); }

        /* --- BOTTOM CONTROLS --- */
        .controls-wrapper {
            position: fixed; bottom: 24px; left: 0; width: 100%;
            display: flex; justify-content: center; z-index: 60; pointer-events: none;
        }
        .control-bar {
            background: var(--glass-bg); backdrop-filter: blur(16px);
            padding: 10px 20px; border-radius: 50px; border: 1px solid var(--border);
            display: flex; gap: 12px; pointer-events: auto;
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }
        .btn-ctrl {
            width: 48px; height: 48px; border-radius: 50%; border: none;
            background: transparent; color: white; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: 0.2s; position: relative;
        }
        .btn-ctrl:hover { background: rgba(255,255,255,0.15); }
        .btn-ctrl.active { background: var(--primary); color: black; }
        .btn-ctrl.off-red { background: var(--danger); color: white; }
        .btn-ctrl.hangup { background: var(--danger); width: 64px; border-radius: 32px; margin-left: 8px;}

        .unread-dot {
            position: absolute; top: 10px; right: 10px; width: 10px; height: 10px;
            background: var(--danger); border-radius: 50%; border: 2px solid #2e2e2e; display: none;
        }

        /* --- GLOBAL ACTIONS MENU (Bottom Sheet/Popup) --- */
        #actions-menu {
            position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%) translateY(20px);
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 16px; padding: 8px; width: 280px;
            display: none; flex-direction: column; z-index: 70; opacity: 0;
            transition: all 0.2s; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #actions-menu.open { display: flex; transform: translateX(-50%) translateY(0); opacity: 1; }
        
        .action-item {
            padding: 12px 16px; display: flex; align-items: center; gap: 12px;
            color: white; background: none; border: none; cursor: pointer;
            border-radius: 8px; font-size: 14px; text-align: left;
        }
        .action-item:hover { background: rgba(255,255,255,0.1); }
        .action-item.active-opt { color: var(--primary); background: rgba(138, 180, 248, 0.1); }

        /* --- CHAT DRAWER --- */
        #chat-drawer {
            position: fixed; top: 16px; bottom: 16px; right: 16px; width: 320px;
            background: var(--surface); border-radius: 16px; border: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 100;
            transform: translateX(120%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: -10px 0 40px rgba(0,0,0,0.6);
        }
        #chat-drawer.open { transform: translateX(0); }
        @media (max-width: 768px) {
            #chat-drawer {
                top: auto; bottom: 0; left: 0; right: 0; width: 100%; height: 85vh;
                border-radius: 24px 24px 0 0; transform: translateY(100%);
            }
            #chat-drawer.open { transform: translateY(0); }
        }
        .chat-header { padding: 18px 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; font-weight: 500; font-size: 18px; }
        .chat-body { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 16px; }
        .msg { display: flex; flex-direction: column; max-width: 85%; }
        .msg.me { align-self: flex-end; align-items: flex-end; } .msg.them { align-self: flex-start; align-items: flex-start; }
        .msg-bubble { padding: 12px 16px; border-radius: 20px; font-size: 14px; line-height: 1.5; word-wrap: break-word; }
        .msg.me .msg-bubble { background: var(--primary); color: #121212; border-bottom-right-radius: 4px; }
        .msg.them .msg-bubble { background: #333; color: white; border-bottom-left-radius: 4px; }
        .chat-footer { padding: 16px 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; }
        .chat-input { flex: 1; background: #2c2c2c; border: none; padding: 14px; border-radius: 24px; color: white; outline: none; }
        .chat-send { background: none; border: none; color: var(--primary); cursor: pointer; padding: 8px; }

    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <div class="logo"><i data-lucide="video" color="#8ab4f8"></i> Edulinki</div>
            <div id="room-badge" class="room-badge"></div>
        </div>
    </header>

    <div id="lobby">
        <div class="lobby-card">
            <h1>Join Meeting</h1>
            <p style="color:var(--text-muted); margin-bottom: 24px;">Premium video conferencing.</p>
            <input type="text" id="roomInput" class="input-box" placeholder="Enter Room Code" autocomplete="off">
            <button id="joinBtn" class="btn-primary" disabled>Join Room</button>
            <button id="createBtn" class="btn-text">Create New Meeting</button>
        </div>
    </div>

    <div id="meeting-stage">
        <div id="video-grid">
            </div>
    </div>

    <div id="chat-drawer">
        <div class="chat-header">
            <span>Messages</span>
            <button onclick="toggleChat()" style="background:none; border:none; color:var(--text-muted); cursor:pointer;"><i data-lucide="x"></i></button>
        </div>
        <div class="chat-body" id="chatBody"></div>
        <div class="chat-footer">
            <input type="text" id="chatInput" class="chat-input" placeholder="Type a message..." autocomplete="off">
            <button id="sendBtn" class="chat-send" disabled><i data-lucide="send-horizontal"></i></button>
        </div>
    </div>

    <div class="controls-wrapper" id="controls" style="display:none;">
        <div class="control-bar">
            <button id="micBtn" class="btn-ctrl" title="Mic"><i data-lucide="mic"></i></button>
            <button id="camBtn" class="btn-ctrl" title="Camera"><i data-lucide="camera"></i></button>
            
            <button id="actionsBtn" class="btn-ctrl" title="More Options"><i data-lucide="more-vertical"></i></button>

            <button id="chatBtn" class="btn-ctrl" title="Chat" onclick="toggleChat()">
                <i data-lucide="message-square"></i>
                <div class="unread-dot" id="unreadDot"></div>
            </button>
            <button id="hangupBtn" class="btn-ctrl hangup" title="Leave"><i data-lucide="phone-off"></i></button>
        </div>
    </div>

    <div id="actions-menu">
        <button class="action-item" id="handOption">
            <i data-lucide="hand" size="18"></i> Raise Hand
        </button>
        <button class="action-item" id="screenOption">
            <i data-lucide="monitor-up" size="18"></i> Share Screen
        </button>
        <div style="height:1px; background:var(--border); margin:4px 0;"></div>
        <button class="action-item" onclick="sendReaction('üíñ')">üíñ Heart</button>
        <button class="action-item" onclick="sendReaction('üòÇ')">üòÇ Laugh</button>
        <button class="action-item" onclick="sendReaction('üëè')">üëè Clap</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, addDoc, onSnapshot, updateDoc, deleteDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        lucide.createIcons();

        const firebaseConfig = {
            apiKey: "AIzaSyAJH79UQl0rc96Qug0DKLevO4ZI_sn8Kno",
            authDomain: "edulinki.firebaseapp.com",
            projectId: "edulinki",
            storageBucket: "edulinki.firebasestorage.app",
            messagingSenderId: "248886466474",
            appId: "1:248886466474:web:160043201a6b28bafbbdd3",
            measurementId: "G-MQBH12VL7N"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        const iceServers = { iceServers: [{ urls: ['stun:stun1.l.google.com:19302'] }] };

        // --- STATE ---
        let localStream, screenStream, processedStream;
        let roomId;
        let myId = Math.random().toString(36).substr(2, 5).toUpperCase();
        let pcs = {};
        let audioCtx;
        let isMuted = false, isCamOff = false, isHandRaised = false, isChatOpen = false, isBlurred = false;
        
        // MediaPipe
        let selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`});
        selfieSegmentation.setOptions({ modelSelection: 1 });
        let canvasElement, canvasCtx;

        // DOM
        const grid = document.getElementById('video-grid');
        const actionsMenu = document.getElementById('actions-menu');
        const actionsBtn = document.getElementById('actionsBtn');
        const unreadDot = document.getElementById('unreadDot');

        // --- LAYOUT ---
        function calculateLayout() {
            const count = grid.children.length;
            if(count === 0) return;
            const width = document.getElementById('meeting-stage').clientWidth - 20; 
            const height = document.getElementById('meeting-stage').clientHeight - 100;
            let bestCols = 1; let maxArea = 0;
            for (let cols = 1; cols <= count; cols++) {
                const rows = Math.ceil(count / cols);
                const hScale = width / cols;
                const vScale = height / rows;
                let cardW, cardH;
                if (hScale * (9/16) < vScale) { cardW = hScale; cardH = hScale * (9/16); } 
                else { cardH = vScale; cardW = vScale * (16/9); }
                if (cardW * cardH > maxArea) { maxArea = cardW * cardH; bestCols = cols; }
            }
            const finalW = (width / bestCols) - 16; 
            const finalH = finalW * (9/16);
            Array.from(grid.children).forEach(card => {
                card.style.width = `${finalW}px`; card.style.height = `${finalH}px`;
            });
        }
        window.onresize = calculateLayout;

        // --- VIDEO CARDS & MENUS ---
        function addVideoCard(uid, stream, isLocal) {
            if(document.getElementById(`vid-${uid}`)) return;
            const card = document.createElement('div');
            card.className = 'vid-card';
            card.id = `vid-${uid}`;
            
            let menuHtml = '';
            if(isLocal) {
                menuHtml = `
                    <button class="card-menu-btn" onclick="toggleCardMenu('${uid}')"><i data-lucide="more-horizontal"></i></button>
                    <div class="card-dropdown" id="menu-${uid}">
                        <button class="card-option" onclick="toggleBlur()"><i data-lucide="aperture"></i> Blur Background</button>
                    </div>
                `;
            }

            card.innerHTML = `
                <video autoplay playsinline class="${isLocal ? 'mirrored' : ''}" ${isLocal ? 'muted' : ''}></video>
                <div class="avatar" style="background:${stringToColor(uid)}">${uid[0]}</div>
                <div class="name-tag"><i data-lucide="mic-off" class="status-icon" size="12"></i><span>${isLocal ? 'You' : uid}</span></div>
                <div class="hand-badge"><i data-lucide="hand" color="white" size="16"></i></div>
                ${menuHtml}
            `;
            
            const vid = card.querySelector('video');
            vid.srcObject = stream;
            
            grid.appendChild(card);
            lucide.createIcons();
            calculateLayout();
        }

        window.toggleCardMenu = (uid) => {
            const menu = document.getElementById(`menu-${uid}`);
            if(menu) menu.classList.toggle('show');
        };
        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            if(!e.target.closest('.card-menu-btn') && !e.target.closest('.card-dropdown')) {
                document.querySelectorAll('.card-dropdown').forEach(m => m.classList.remove('show'));
            }
            if(!e.target.closest('#actions-menu') && !e.target.closest('#actionsBtn')) {
                actionsMenu.classList.remove('open');
            }
        });

        // --- BLUR LOGIC ---
        window.toggleBlur = async () => {
            isBlurred = !isBlurred;
            const menu = document.getElementById(`menu-${myId}`);
            if(menu) menu.classList.remove('show');

            const videoEl = document.querySelector(`#vid-${myId} video`);

            if(isBlurred) {
                // Initialize Blur
                if(!canvasElement) {
                    canvasElement = document.createElement('canvas');
                    canvasCtx = canvasElement.getContext('2d');
                    selfieSegmentation.onResults(onResults);
                }
                
                // Start Loop
                const process = async () => {
                    if(!isBlurred) return;
                    await selfieSegmentation.send({image: videoEl});
                    requestAnimationFrame(process);
                };
                
                // Create stream from canvas
                processedStream = canvasElement.captureStream(30);
                // Add audio back
                localStream.getAudioTracks().forEach(t => processedStream.addTrack(t));
                
                // Switch tracks for peers
                const videoTrack = processedStream.getVideoTracks()[0];
                for(let uid in pcs) {
                    const sender = pcs[uid].getSenders().find(s => s.track.kind === 'video');
                    if(sender) sender.replaceTrack(videoTrack);
                }
                
                // Local view (We view the canvas result implicitly or swap srcObject)
                // Actually MediaPipe needs the raw video playing to process it.
                // We keep videoEl playing raw stream, BUT we overlay the canvas? 
                // Easier: Just replace the video element src with the processed stream
                // Wait, if we replace srcObject, we lose input.
                // Solution: Keep video element raw but hidden? No.
                // Standard: create a hidden video element for input, show canvas in the grid.
                // For simplicity in this UI: We will just swap the track sent to peers. Local user sees raw (or we'd need to swap DOM).
                // Let's swap the DOM element to a canvas for the local user to see the blur.
                
                const card = document.getElementById(`vid-${myId}`);
                let displayCanvas = card.querySelector('canvas');
                if(!displayCanvas) {
                    displayCanvas = document.createElement('canvas');
                    displayCanvas.className = 'mirrored';
                    card.insertBefore(displayCanvas, videoEl);
                    videoEl.style.display = 'none'; // Hide raw video
                }
                displayCanvas.style.display = 'block';
                
                // Update the render loop to draw to this displayCanvas
                selfieSegmentation.onResults((results) => {
                    // Draw to the stream canvas
                    drawBlur(canvasCtx, canvasElement, results);
                    // Draw to visible canvas
                    const dispCtx = displayCanvas.getContext('2d');
                    displayCanvas.width = videoEl.videoWidth;
                    displayCanvas.height = videoEl.videoHeight;
                    drawBlur(dispCtx, displayCanvas, results);
                });
                
                process();

            } else {
                // Stop Blur
                const card = document.getElementById(`vid-${myId}`);
                const displayCanvas = card.querySelector('canvas');
                if(displayCanvas) displayCanvas.style.display = 'none';
                videoEl.style.display = 'block';

                const rawTrack = localStream.getVideoTracks()[0];
                for(let uid in pcs) {
                    const sender = pcs[uid].getSenders().find(s => s.track.kind === 'video');
                    if(sender) sender.replaceTrack(rawTrack);
                }
            }
        };

        function drawBlur(ctx, canvas, results) {
            canvas.width = results.image.width;
            canvas.height = results.image.height;
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-in';
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'destination-over';
            ctx.filter = 'blur(10px)';
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
        function onResults(results) { /* Handled in closure above */ }

        // --- INIT ---
        document.getElementById('roomInput').oninput = (e) => document.getElementById('joinBtn').disabled = !e.target.value;
        document.getElementById('createBtn').onclick = () => start(Math.random().toString(36).substr(2, 6));
        document.getElementById('joinBtn').onclick = () => start(document.getElementById('roomInput').value.trim());

        async function start(id) {
            roomId = id;
            document.getElementById('room-badge').innerText = `ID: ${roomId}`;
            document.getElementById('room-badge').style.display = 'block';
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('meeting-stage').style.display = 'block';
            document.getElementById('controls').style.display = 'flex';
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                addVideoCard(myId, localStream, true);
                await joinRoom();
            } catch(e) { alert("Camera Error"); }
        }

        async function joinRoom() {
            const userRef = doc(db, `rooms/${roomId}/users/${myId}`);
            await setDoc(userRef, { present: true, mic: true, cam: true, hand: false });
            window.onbeforeunload = () => deleteDoc(userRef);

            // Listeners... (Same as previous, shortened for brevity)
            onSnapshot(collection(db, `rooms/${roomId}/users`), (snap) => {
                snap.docChanges().forEach(change => {
                    const uid = change.doc.id; const data = change.doc.data();
                    if(uid === myId) return;
                    if(change.type === 'removed') { 
                        const el = document.getElementById(`vid-${uid}`); if(el) { el.remove(); calculateLayout(); }
                        if(pcs[uid]) { pcs[uid].close(); delete pcs[uid]; }
                    } else {
                        const el = document.getElementById(`vid-${uid}`);
                        if(el) {
                            el.classList.toggle('muted', !data.mic); el.classList.toggle('cam-off', !data.cam); el.classList.toggle('hand-up', data.hand);
                        }
                        if(change.type === 'added' && !pcs[uid]) (myId < uid) ? createPeer(uid, true) : createPeer(uid, false);
                    }
                });
            });
            onSnapshot(collection(db, `rooms/${roomId}/signals`), (snap) => {
                snap.docChanges().forEach(async change => {
                    if(change.type === 'added' && change.doc.data().to === myId) {
                        await handleSignal(change.doc.data()); deleteDoc(change.doc.ref);
                    }
                });
            });
            onSnapshot(query(collection(db, `rooms/${roomId}/chat`), orderBy('ts')), (snap) => {
                snap.docChanges().forEach(change => {
                    if(change.type === 'added') { renderMsg(change.doc.data()); if(!isChatOpen) unreadDot.style.display = 'block'; }
                });
            });
        }

        // --- WEBRTC ---
        async function createPeer(uid, initiator) {
            const pc = new RTCPeerConnection(iceServers);
            pcs[uid] = pc;
            pc.onicecandidate = e => e.candidate && sendSignal({ type: 'candidate', candidate: e.candidate.toJSON(), to: uid, from: myId });
            pc.ontrack = e => addVideoCard(uid, e.streams[0], false);
            // Send either processed or raw stream
            const streamToSend = isBlurred && processedStream ? processedStream : localStream;
            streamToSend.getTracks().forEach(t => pc.addTrack(t, streamToSend));
            if(initiator) {
                const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
                sendSignal({ type: 'offer', sdp: offer.sdp, to: uid, from: myId });
            }
        }
        async function handleSignal(msg) {
            const pc = pcs[msg.from] || (await createPeer(msg.from, false), pcs[msg.from]);
            if(msg.type === 'offer') {
                await pc.setRemoteDescription(new RTCSessionDescription({type:'offer', sdp:msg.sdp}));
                const ans = await pc.createAnswer(); await pc.setLocalDescription(ans);
                sendSignal({ type: 'answer', sdp: ans.sdp, to: msg.from, from: myId });
            } else if (msg.type === 'answer') await pc.setRemoteDescription(new RTCSessionDescription({type:'answer', sdp:msg.sdp}));
            else if (msg.type === 'candidate') await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
        }
        async function sendSignal(data) { await addDoc(collection(db, `rooms/${roomId}/signals`), data); }
        function stringToColor(str) { let hash=0; for(let i=0; i<str.length; i++) hash = str.charCodeAt(i)+((hash<<5)-hash); return `hsl(${hash%360},60%,50%)`; }

        // --- CONTROLS ---
        const myDoc = () => doc(db, `rooms/${roomId}/users/${myId}`);
        document.getElementById('micBtn').onclick = (e) => {
            isMuted = !isMuted; localStream.getAudioTracks()[0].enabled = !isMuted;
            updateBtn(e.currentTarget, isMuted, 'mic', 'mic-off'); updateDoc(myDoc(), { mic: !isMuted });
            document.getElementById(`vid-${myId}`).classList.toggle('muted', isMuted);
        };
        document.getElementById('camBtn').onclick = (e) => {
            isCamOff = !isCamOff; 
            // Only disable track if not blurring (MediaPipe needs video running)
            if(!isBlurred) localStream.getVideoTracks()[0].enabled = !isCamOff;
            
            updateBtn(e.currentTarget, isCamOff, 'camera', 'camera-off'); updateDoc(myDoc(), { cam: !isCamOff });
            document.getElementById(`vid-${myId}`).classList.toggle('cam-off', isCamOff);
        };
        function updateBtn(btn, off, iconOn, iconOff) {
            btn.classList.toggle('off-red', off); btn.innerHTML = `<i data-lucide="${off ? iconOff : iconOn}"></i>`; lucide.createIcons();
        }

        // ACTIONS MENU (Raise Hand / Share Screen)
        actionsBtn.onclick = () => actionsMenu.classList.toggle('open');
        
        document.getElementById('handOption').onclick = () => {
            isHandRaised = !isHandRaised; updateDoc(myDoc(), { hand: isHandRaised });
            document.getElementById('handOption').classList.toggle('active-opt', isHandRaised);
            actionsMenu.classList.remove('open');
        };

        document.getElementById('screenOption').onclick = async () => {
            if(!screenStream) {
                try {
                    screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                    const trk = screenStream.getVideoTracks()[0];
                    for(let uid in pcs) {
                        const snd = pcs[uid].getSenders().find(s => s.track.kind === 'video');
                        if(snd) snd.replaceTrack(trk);
                    }
                    // Local view
                    const vid = document.querySelector(`#vid-${myId} video`);
                    vid.srcObject = screenStream;
                    vid.classList.remove('mirrored');
                    if(document.querySelector(`#vid-${myId} canvas`)) document.querySelector(`#vid-${myId} canvas`).style.display='none';
                    vid.style.display='block';
                    
                    document.getElementById('screenOption').classList.add('active-opt');
                    actionsMenu.classList.remove('open');
                    trk.onended = stopScreen;
                } catch(e){}
            } else stopScreen();
        };

        function stopScreen() {
            const trk = (isBlurred && processedStream) ? processedStream.getVideoTracks()[0] : localStream.getVideoTracks()[0];
            for(let uid in pcs) {
                const snd = pcs[uid].getSenders().find(s => s.track.kind === 'video');
                if(snd) snd.replaceTrack(trk);
            }
            const vid = document.querySelector(`#vid-${myId} video`);
            vid.srcObject = localStream; 
            vid.classList.add('mirrored');
            
            if(isBlurred) {
                vid.style.display='none';
                document.querySelector(`#vid-${myId} canvas`).style.display='block';
            }
            
            document.getElementById('screenOption').classList.remove('active-opt');
            if(screenStream) screenStream.getTracks().forEach(t=>t.stop()); screenStream=null;
        }

        window.sendReaction = (emoji) => {
            addDoc(collection(db, `rooms/${roomId}/chat`), { sender: myId, text: emoji, ts: Date.now() }); // Using chat for now
            actionsMenu.classList.remove('open');
        };

        // CHAT
        window.toggleChat = () => {
            isChatOpen = !isChatOpen; document.getElementById('chat-drawer').classList.toggle('open', isChatOpen);
            document.getElementById('chatBtn').classList.toggle('active', isChatOpen);
            document.getElementById('meeting-stage').classList.toggle('drawer-open', isChatOpen);
            if(isChatOpen) { unreadDot.style.display='none'; setTimeout(calculateLayout, 300); }
        };
        document.getElementById('chatInput').onkeydown = (e) => { if(e.key==='Enter') sendMsg(); };
        document.getElementById('sendBtn').onclick = sendMsg;
        async function sendMsg() {
            const txt = document.getElementById('chatInput').value.trim(); if(!txt)return;
            document.getElementById('chatInput').value='';
            await addDoc(collection(db, `rooms/${roomId}/chat`), { sender: myId, text: txt, ts: Date.now() });
        }
        function renderMsg(msg) {
            const d = document.createElement('div'); d.className = `msg ${msg.sender===myId?'me':'them'}`;
            d.innerHTML = `<div class="msg-name">${msg.sender===myId?'You':msg.sender}</div><div class="msg-bubble">${msg.text}</div>`;
            const b = document.getElementById('chatBody'); b.appendChild(d); b.scrollTop=b.scrollHeight;
        }
        document.getElementById('hangupBtn').onclick = () => window.location.reload();

    </script>
</body>
</html>
