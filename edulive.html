<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edulinki Force Connect</title>
    <style>
        body { font-family: monospace; background: #121212; color: #0f0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; margin: 0; padding: 10px; }
        .container { width: 100%; max-width: 800px; display: flex; flex-direction: column; gap: 15px; }
        
        .controls { background: #222; padding: 20px; border-radius: 8px; border: 1px solid #333; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
        input { background: #000; color: white; border: 1px solid #555; padding: 10px; border-radius: 4px; font-family: monospace; }
        button { padding: 10px 20px; font-weight: bold; cursor: pointer; border: none; border-radius: 4px; }
        #createBtn { background: #007bff; color: white; }
        #joinBtn { background: #28a745; color: white; }
        #hangupBtn { background: #dc3545; color: white; }

        .status { background: #1a1a1a; padding: 10px; border-radius: 4px; border: 1px solid #333; min-height: 40px; white-space: pre-wrap; word-break: break-all; font-size: 0.9em; }
        
        .video-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .vid-box { position: relative; background: #000; border: 1px solid #333; aspect-ratio: 16/9; }
        video { width: 100%; height: 100%; object-fit: cover; }
        .label { position: absolute; bottom: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 5px; font-size: 10px; }
    </style>
</head>
<body>

    <div class="container">
        <h2 style="text-align: center; margin: 5px;">Edulinki Connector v3</h2>
        
        <div class="controls">
            <input type="text" id="callInput" placeholder="Enter Room Name" />
            <button id="createBtn">CREATE Call</button>
            <button id="joinBtn">JOIN Call</button>
            <button id="hangupBtn" disabled>Reset</button>
        </div>

        <div class="status" id="statusLogs">Log: Waiting for user action...</div>

        <div class="video-grid">
            <div class="vid-box">
                <video id="localVideo" autoplay playsinline muted></video>
                <div class="label">YOU</div>
            </div>
            <div class="vid-box">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="label">THEM</div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, addDoc, onSnapshot, getDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        // CONFIGURATION
        const firebaseConfig = {
            apiKey: "AIzaSyAJH79UQl0rc96Qug0DKLevO4ZI_sn8Kno",
            authDomain: "edulinki.firebaseapp.com",
            projectId: "edulinki",
            storageBucket: "edulinki.firebasestorage.app",
            messagingSenderId: "248886466474",
            appId: "1:248886466474:web:160043201a6b28bafbbdd3",
            measurementId: "G-MQBH12VL7N"
        };

        const app = initializeApp(firebaseConfig);
        const firestore = getFirestore(app);

        // MAXIMUM STUN SERVERS
        const servers = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] },
                { urls: ['stun:stun3.l.google.com:19302', 'stun:stun4.l.google.com:19302'] },
                { urls: ['stun:global.stun.twilio.com:3478'] } 
            ],
            iceCandidatePoolSize: 10,
        };

        let pc = new RTCPeerConnection(servers);
        let localStream = null;
        let remoteStream = null;

        // UI Elements
        const logDiv = document.getElementById('statusLogs');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const callInput = document.getElementById('callInput');
        const createBtn = document.getElementById('createBtn');
        const joinBtn = document.getElementById('joinBtn');
        const hangupBtn = document.getElementById('hangupBtn');

        function log(msg) {
            console.log(msg);
            logDiv.innerText = msg + "\n" + logDiv.innerText;
        }

        // 1. SETUP MEDIA
        async function startMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                
                remoteStream = new MediaStream();
                pc.ontrack = (event) => {
                    log("ðŸŽ¥ Received remote video track!");
                    event.streams[0].getTracks().forEach((track) => remoteStream.addTrack(track));
                    remoteVideo.srcObject = remoteStream;
                };

                localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
                return true;
            } catch (e) {
                log("âŒ ERROR: Could not get Camera. Allow permissions!");
                return false;
            }
        }

        // 2. MONITOR CONNECTION STATE
        pc.onconnectionstatechange = () => {
            log(`ðŸ”„ Connection State: ${pc.connectionState}`);
            if (pc.connectionState === 'failed') {
                log("âŒ FAILED. Firewall is blocking connection.");
                // OPTIONAL: Restart ICE if failed
                pc.restartIce();
            }
        };

        // 3. ICE CANDIDATE BUFFERING (The Fix)
        // We often receive candidates before the connection is ready. We must queue them.
        let candidateQueue = [];
        
        async function handleRemoteCandidate(candidateData) {
            if (!candidateData) return;
            const candidate = new RTCIceCandidate(candidateData);
            
            if (pc.remoteDescription && pc.remoteDescription.type) {
                try {
                    await pc.addIceCandidate(candidate);
                    log("âœ… Added ICE Candidate");
                } catch (e) {
                    log("âš ï¸ Error adding ICE: " + e.message);
                }
            } else {
                log("â³ Queuing ICE Candidate (Not ready yet)");
                candidateQueue.push(candidate);
            }
        }

        async function processCandidateQueue() {
            log(`ðŸš€ Processing ${candidateQueue.length} queued candidates...`);
            for (const candidate of candidateQueue) {
                try {
                    await pc.addIceCandidate(candidate);
                } catch (e) { console.error(e); }
            }
            candidateQueue = [];
        }

        // CREATE BUTTON
        createBtn.onclick = async () => {
            const callId = callInput.value.trim();
            if(!callId || !await startMedia()) return;
            
            createBtn.disabled = true; joinBtn.disabled = true;
            hangupBtn.disabled = false;

            const callDoc = doc(collection(firestore, 'calls'), callId);
            const offerCandidates = collection(callDoc, 'offerCandidates');
            const answerCandidates = collection(callDoc, 'answerCandidates');

            // Send my candidates to DB
            pc.onicecandidate = (event) => {
                event.candidate && addDoc(offerCandidates, event.candidate.toJSON());
            };

            // Create Offer
            const offerDescription = await pc.createOffer();
            await pc.setLocalDescription(offerDescription);
            
            const offer = { sdp: offerDescription.sdp, type: offerDescription.type };
            await setDoc(callDoc, { offer });
            log(`ðŸ“¡ Offer Created! Waiting for answer on room: ${callId}`);

            // Listen for Answer
            onSnapshot(callDoc, (snapshot) => {
                const data = snapshot.data();
                if (!pc.currentRemoteDescription && data?.answer) {
                    const answerDescription = new RTCSessionDescription(data.answer);
                    pc.setRemoteDescription(answerDescription);
                    log("ðŸ¤ Received Answer! Connecting...");
                    processCandidateQueue(); // Process any candidates that arrived early
                }
            });

            // Listen for Remote Candidates
            onSnapshot(answerCandidates, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') handleRemoteCandidate(change.doc.data());
                });
            });
        };

        // JOIN BUTTON
        joinBtn.onclick = async () => {
            const callId = callInput.value.trim();
            if(!callId || !await startMedia()) return;

            createBtn.disabled = true; joinBtn.disabled = true;
            hangupBtn.disabled = false;

            const callDoc = doc(collection(firestore, 'calls'), callId);
            const offerCandidates = collection(callDoc, 'offerCandidates');
            const answerCandidates = collection(callDoc, 'answerCandidates');

            pc.onicecandidate = (event) => {
                event.candidate && addDoc(answerCandidates, event.candidate.toJSON());
            };

            const snapshot = await getDoc(callDoc);
            const callData = snapshot.data();

            if (!callData) {
                alert("Room not found!");
                window.location.reload();
                return;
            }

            log("ðŸ“¥ Received Offer. Sending Answer...");
            
            // Set Remote Description (Offer)
            await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));
            
            // Create Answer
            const answerDescription = await pc.createAnswer();
            await pc.setLocalDescription(answerDescription);

            const answer = { type: answerDescription.type, sdp: answerDescription.sdp };
            await updateDoc(callDoc, { answer });
            
            // Now that remote desc is set, process any queued candidates
            processCandidateQueue();

            // Listen for Remote Candidates
            onSnapshot(offerCandidates, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') handleRemoteCandidate(change.doc.data());
                });
            });
        };

        hangupBtn.onclick = () => window.location.reload();

    </script>
</body>
</html>
