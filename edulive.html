<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EduLive - Realtime Classroom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary: #F20045; /* TikTok/Live Red */
            --dark: #121212;
            --gray: #1E1E1E;
        }
        body { background-color: var(--dark); color: white; font-family: 'Inter', sans-serif; overflow: hidden; }
        
        /* Layouts */
        #app-container { display: flex; height: 100vh; width: 100vw; }
        
        /* Video Grid */
        #main-stage { 
            flex: 3; 
            background: black; 
            position: relative; 
            display: flex; 
            flex-wrap: wrap; 
            align-content: center; 
            justify-content: center;
            gap: 10px;
            padding: 10px;
        }
        
        .video-card {
            position: relative;
            background: #2a2a2a;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
            flex-grow: 1;
            max-width: 100%;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        /* Dynamic sizing based on participant count */
        .video-card:first-child:nth-last-child(1) { width: 100%; height: 100%; }
        .video-card:first-child:nth-last-child(2), .video-card:first-child:nth-last-child(2) ~ .video-card { width: 48%; }
        .video-card:first-child:nth-last-child(3), .video-card:first-child:nth-last-child(3) ~ .video-card { width: 48%; }
        .video-card:first-child:nth-last-child(4), .video-card:first-child:nth-last-child(4) ~ .video-card { width: 48%; }

        video { width: 100%; height: 100%; object-fit: cover; }
        
        .user-label {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.6); padding: 4px 10px;
            border-radius: 4px; font-size: 12px; font-weight: bold;
        }

        /* Sidebar (Chat & Controls) */
        #sidebar { 
            flex: 1; 
            min-width: 300px; 
            max-width: 400px;
            background: var(--gray); 
            display: flex; 
            flex-direction: column;
            border-left: 1px solid #333;
        }

        /* Lobby Styles */
        #lobby {
            position: fixed; inset: 0; z-index: 50;
            background: var(--dark);
            display: flex; align-items: center; justify-content: center;
        }
        .lobby-box {
            background: var(--gray); padding: 2rem; border-radius: 16px;
            width: 90%; max-width: 400px; text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* Chat */
        #chat-area { flex-grow: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 8px; }
        .msg { font-size: 14px; line-height: 1.4; }
        .msg strong { color: #aaa; margin-right: 5px; }
        .msg-system { color: #F20045; font-style: italic; }

        /* Controls */
        .controls { padding: 1rem; background: #252525; display: grid; gap: 10px; }
        .btn {
            border: none; padding: 10px 15px; border-radius: 8px;
            font-weight: 600; cursor: pointer; transition: 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { opacity: 0.9; }
        .btn-secondary { background: #444; color: white; }
        .btn-green { background: #00c853; color: white; }
        
        input {
            width: 100%; padding: 10px; margin-bottom: 10px;
            background: #333; border: 1px solid #444; color: white; border-radius: 6px;
        }

        /* Notification Toast */
        #toast {
            position: fixed; top: 20px; right: 20px;
            background: var(--primary); color: white;
            padding: 10px 20px; border-radius: 8px;
            transform: translateX(200%); transition: 0.3s;
            z-index: 100;
        }
        .show-toast { transform: translateX(0) !important; }

        /* Request Badge */
        .guest-req {
            background: #333; padding: 8px; border-radius: 6px;
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 5px; border: 1px solid #555;
        }
    </style>
</head>
<body>

    <div id="lobby">
        <div class="lobby-box">
            <h1 class="text-3xl font-bold mb-2"><span style="color:var(--primary)">Edu</span>Live</h1>
            <p class="text-gray-400 mb-6">Create or Join a Live Classroom</p>
            
            <input type="text" id="username" placeholder="Your Name" value="Guest">
            <input type="text" id="room-id" placeholder="Room ID (e.g., math-101)">
            
            <div class="grid grid-cols-2 gap-3 mt-4">
                <button id="btn-create" class="btn btn-primary"><i class="fas fa-video"></i> Create Host</button>
                <button id="btn-join" class="btn btn-secondary"><i class="fas fa-eye"></i> Join Viewer</button>
            </div>
            <p class="text-xs text-gray-500 mt-4">Make sure to allow Camera/Mic permissions.</p>
        </div>
    </div>

    <div id="app-container" style="display:none;">
        <div id="main-stage">
            </div>

        <div id="sidebar">
            <div class="p-4 border-b border-gray-700 bg-gray-900">
                <h2 class="font-bold text-lg"><span id="room-display"></span></h2>
                <div class="text-xs text-gray-400 flex justify-between">
                    <span id="role-display">Viewer</span>
                    <span><i class="fas fa-user"></i> <span id="participant-count">0</span></span>
                </div>
            </div>

            <div id="host-requests" class="hidden p-2 bg-gray-800 border-b border-gray-700">
                <h3 class="text-xs uppercase text-gray-500 font-bold mb-2">Guest Requests</h3>
                <div id="req-list"></div>
            </div>

            <div id="chat-area"></div>

            <div class="controls">
                <div id="viewer-controls" class="hidden">
                    <button id="btn-request-guest" class="btn btn-secondary w-full">
                        <i class="fas fa-hand-paper"></i> Request to Speak
                    </button>
                </div>

                <div id="media-controls" class="hidden grid grid-cols-3 gap-2">
                    <button id="btn-mute" class="btn btn-secondary"><i class="fas fa-microphone"></i></button>
                    <button id="btn-cam" class="btn btn-secondary"><i class="fas fa-video"></i></button>
                    <button id="btn-leave" class="btn bg-red-600 text-white"><i class="fas fa-phone-slash"></i></button>
                </div>

                <div class="flex gap-2">
                    <input type="text" id="chat-input" placeholder="Type a comment..." class="mb-0">
                    <button id="btn-send" class="btn btn-primary" style="width: auto;"><i class="fas fa-paper-plane"></i></button>
                </div>
            </div>
        </div>
    </div>

    <div id="toast">Notification</div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, addDoc, onSnapshot, updateDoc, deleteDoc, getDoc, serverTimestamp, arrayUnion } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyAJH79UQl0rc96Qug0DKLevO4ZI_sn8Kno",
            authDomain: "edulinki.firebaseapp.com",
            projectId: "edulinki",
            storageBucket: "edulinki.firebasestorage.app",
            messagingSenderId: "248886466474",
            appId: "1:248886466474:web:160043201a6b28bafbbdd3",
            measurementId: "G-MQBH12VL7N"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- STATE VARIABLES ---
        const configuration = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }
            ]
        };

        let localStream = null;
        let peerConnections = {}; // Key: userId, Value: RTCPeerConnection
        let roomId = null;
        let currentUser = null; // { id, name, role }
        let isPublished = false; // Is local video pushed?

        // --- DOM ELEMENTS ---
        const lobby = document.getElementById('lobby');
        const appContainer = document.getElementById('app-container');
        const mainStage = document.getElementById('main-stage');
        const chatArea = document.getElementById('chat-area');
        const reqList = document.getElementById('req-list');
        const hostRequests = document.getElementById('host-requests');
        const mediaControls = document.getElementById('media-controls');
        const viewerControls = document.getElementById('viewer-controls');

        // --- INITIALIZATION HANDLERS ---
        document.getElementById('btn-create').addEventListener('click', () => initRoom(true));
        document.getElementById('btn-join').addEventListener('click', () => initRoom(false));
        document.getElementById('btn-send').addEventListener('click', sendChat);
        document.getElementById('btn-request-guest').addEventListener('click', requestGuestAccess);
        document.getElementById('btn-mute').addEventListener('click', toggleAudio);
        document.getElementById('btn-cam').addEventListener('click', toggleVideo);
        document.getElementById('chat-input').addEventListener('keypress', (e) => { if(e.key === 'Enter') sendChat() });

        async function initRoom(isHost) {
            const rId = document.getElementById('room-id').value.trim();
            const uName = document.getElementById('username').value.trim();
            
            if (!rId || !uName) return showToast("Please enter ID and Name");

            roomId = rId;
            currentUser = {
                id: Date.now().toString(),
                name: uName,
                role: isHost ? 'host' : 'viewer'
            };

            // UI Switch
            lobby.style.display = 'none';
            appContainer.style.display = 'flex';
            document.getElementById('room-display').innerText = `Room: ${roomId}`;
            document.getElementById('role-display').innerText = isHost ? 'HOST' : 'Viewer';

            if (isHost) {
                await startLocalStream();
                hostRequests.classList.remove('hidden');
                mediaControls.classList.remove('hidden');
            } else {
                viewerControls.classList.remove('hidden');
            }

            joinSignaling(isHost);
        }

        // --- MEDIA HANDLING ---
        async function startLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                addVideoCard(currentUser.id, currentUser.name, localStream, true);
                isPublished = true;
                mediaControls.classList.remove('hidden');
            } catch (err) {
                console.error("Error accessing media", err);
                showToast("Camera/Mic blocked or error.");
            }
        }

        function addVideoCard(uid, name, stream, isLocal = false) {
            if (document.getElementById(`vid-${uid}`)) return;

            const div = document.createElement('div');
            div.className = 'video-card';
            div.id = `vid-${uid}`;
            
            const vid = document.createElement('video');
            vid.autoplay = true;
            vid.playsInline = true;
            vid.srcObject = stream;
            if (isLocal) vid.muted = true; // Don't hear yourself

            const label = document.createElement('div');
            label.className = 'user-label';
            label.innerText = name;

            div.appendChild(vid);
            div.appendChild(label);
            mainStage.appendChild(div);
        }

        function removeVideoCard(uid) {
            const el = document.getElementById(`vid-${uid}`);
            if (el) el.remove();
        }

        function toggleAudio() {
            if(localStream) {
                const track = localStream.getAudioTracks()[0];
                track.enabled = !track.enabled;
                document.getElementById('btn-mute').innerHTML = track.enabled ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
            }
        }

        function toggleVideo() {
            if(localStream) {
                const track = localStream.getVideoTracks()[0];
                track.enabled = !track.enabled;
                document.getElementById('btn-cam').innerHTML = track.enabled ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
            }
        }

        // --- SIGNALING (WEB RTC) ---
        // This is a simplified mesh topology.
        
        async function joinSignaling(isHost) {
            const roomRef = doc(db, 'rooms', roomId);
            
            // 1. Add user to participants list (Simplified for presence)
            // Ideally we use a subcollection, but for this demo:
            await setDoc(roomRef, { created: serverTimestamp() }, { merge: true });

            // 2. Listen for other candidates/offers
            // We use a subcollection `participants` where each doc is a user
            const userRef = doc(db, 'rooms', roomId, 'participants', currentUser.id);
            await setDoc(userRef, { 
                name: currentUser.name, 
                role: currentUser.role, 
                isPublisher: isPublished 
            });

            // Listen to all participants to handle Mesh connections
            const participantsRef = collection(db, 'rooms', roomId, 'participants');
            onSnapshot(participantsRef, snapshot => {
                snapshot.docChanges().forEach(async change => {
                    if (change.type === 'added') {
                        const data = change.doc.data();
                        const remoteId = change.doc.id;
                        
                        // Update UI Counter
                        document.getElementById('participant-count').innerText = snapshot.size;

                        // If it's not me
                        if (remoteId !== currentUser.id) {
                            // If I am a publisher OR they are a publisher, we need a connection
                            // To simplify: Everyone connects to everyone, but only publishers add tracks.
                            if (currentUser.role === 'host' || data.isPublisher || currentUser.id < remoteId) {
                                // Simple convention: Lower ID initiates offer to Higher ID to prevent double connection
                                // OR: Host always initiates.
                                // Let's try: Existing users initiate to New users.
                                initiateConnection(remoteId, data.name);
                            }
                        }
                    }
                    if (change.type === 'modified') {
                         const data = change.doc.data();
                         // Logic to handle if a viewer becomes a publisher (Guest accepted)
                         if (data.isPublisher && !document.getElementById(`vid-${change.doc.id}`)) {
                             // They started streaming, we might need to renegotiate or just rely on existing connection
                             showToast(`${data.name} is now live!`);
                         }
                    }
                    if (change.type === 'removed') {
                        removeVideoCard(change.doc.id);
                        if(peerConnections[change.doc.id]) {
                            peerConnections[change.doc.id].close();
                            delete peerConnections[change.doc.id];
                        }
                    }
                });
            });

            // Listen for incoming SDP Offers/Answers directed at ME
            const mySignalingRef = collection(db, 'rooms', roomId, 'participants', currentUser.id, 'incoming');
            onSnapshot(mySignalingRef, snapshot => {
                snapshot.docChanges().forEach(async change => {
                    if (change.type === 'added') {
                        const data = change.doc.data();
                        const fromId = data.from;
                        
                        if (data.type === 'offer') {
                            await handleOffer(fromId, data.sdp, data.name);
                        } else if (data.type === 'answer') {
                            await handleAnswer(fromId, data.sdp);
                        } else if (data.type === 'candidate') {
                            await handleCandidate(fromId, data.candidate);
                        }
                        
                        // Clean up processed signals
                        await deleteDoc(change.doc.ref);
                    }
                });
            });
            
            // Listen to Chat
            const chatRef = collection(db, 'rooms', roomId, 'messages');
            onSnapshot(chatRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') renderMessage(change.doc.data());
                });
            });

            // If Host, listen to Guest Requests
            if (isHost) {
                const reqRef = collection(db, 'rooms', roomId, 'requests');
                onSnapshot(reqRef, snapshot => {
                    reqList.innerHTML = '';
                    snapshot.forEach(docSnap => {
                        const r = docSnap.data();
                        renderRequest(docSnap.id, r.name, r.userId);
                    });
                    if(snapshot.empty) hostRequests.classList.add('hidden');
                    else hostRequests.classList.remove('hidden');
                });
            }

            // If Viewer, listen for Acceptance
            if (!isHost) {
                // Determine if we've been accepted by checking our participant doc status or a specific message
                // Simplification: Listen to a "approvals" collection or check our own "isPublisher" flag if host sets it
                // We will use a dedicated listener on our own user doc for a trigger
                onSnapshot(userRef, async (snap) => {
                    const data = snap.data();
                    if (data && data.isGuestAllowed && !localStream) {
                        // Host approved us!
                        showToast("Host accepted you as Guest!");
                        await startLocalStream();
                        // Update my status to publisher so others know to expect video
                        await updateDoc(userRef, { isPublisher: true });
                        
                        // Add tracks to all existing connections
                        Object.values(peerConnections).forEach(pc => {
                            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                            // Note: WebRTC requires renegotiation here. 
                            // In a simple mesh, it's easier to just reload or handle "negotiationneeded".
                            // For this single-file demo, we will rely on the "negotiationneeded" event if implemented
                            // OR simply re-initiate connections.
                            // Trigger renegotiation:
                            // pc.createOffer()... complex.
                        });
                        // Quick hack for demo: Force reload to publish properly or re-initiate manually
                        // showToast("Reconnecting to publish stream...");
                        // window.location.reload(); 
                        // Instead of reload, let's just add tracks. The other side receives 'track' event.
                    }
                });
            }
        }

        // --- WEB RTC CORE ---
        
        function createPeerConnection(remoteId, remoteName) {
            if (peerConnections[remoteId]) return peerConnections[remoteId];

            const pc = new RTCPeerConnection(configuration);
            peerConnections[remoteId] = pc;

            // Handle ICE Candidates
            pc.onicecandidate = event => {
                if (event.candidate) {
                    sendSignal(remoteId, { type: 'candidate', candidate: event.candidate.toJSON(), from: currentUser.id });
                }
            };

            // Handle Incoming Stream
            pc.ontrack = event => {
                if (event.streams && event.streams[0]) {
                    addVideoCard(remoteId, remoteName, event.streams[0]);
                }
            };

            // Add local stream if we have one
            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            return pc;
        }

        async function initiateConnection(remoteId, remoteName) {
            const pc = createPeerConnection(remoteId, remoteName);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            await sendSignal(remoteId, { 
                type: 'offer', 
                sdp: offer, 
                from: currentUser.id, 
                name: currentUser.name 
            });
        }

        async function handleOffer(remoteId, sdp, remoteName) {
            const pc = createPeerConnection(remoteId, remoteName);
            await pc.setRemoteDescription(new RTCSessionDescription(sdp));
            
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            await sendSignal(remoteId, { 
                type: 'answer', 
                sdp: answer, 
                from: currentUser.id 
            });
        }

        async function handleAnswer(remoteId, sdp) {
            const pc = peerConnections[remoteId];
            if (pc) {
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
            }
        }

        async function handleCandidate(remoteId, candidate) {
            const pc = peerConnections[remoteId];
            if (pc) {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
        }

        async function sendSignal(targetUserId, data) {
            const ref = collection(db, 'rooms', roomId, 'participants', targetUserId, 'incoming');
            await addDoc(ref, data);
        }

        // --- CHAT & REQUESTS ---

        async function sendChat() {
            const input = document.getElementById('chat-input');
            const txt = input.value.trim();
            if (!txt) return;

            await addDoc(collection(db, 'rooms', roomId, 'messages'), {
                user: currentUser.name,
                text: txt,
                time: serverTimestamp()
            });
            input.value = '';
        }

        function renderMessage(data) {
            const div = document.createElement('div');
            div.className = 'msg';
            div.innerHTML = `<strong>${data.user}:</strong> ${data.text}`;
            chatArea.appendChild(div);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        async function requestGuestAccess() {
            if (currentUser.role !== 'viewer') return;
            showToast("Request sent to host!");
            await addDoc(collection(db, 'rooms', roomId, 'requests'), {
                userId: currentUser.id,
                name: currentUser.name,
                created: serverTimestamp()
            });
            document.getElementById('btn-request-guest').disabled = true;
            document.getElementById('btn-request-guest').innerText = "Request Sent...";
        }

        function renderRequest(reqId, name, userId) {
            const div = document.createElement('div');
            div.className = 'guest-req';
            div.innerHTML = `
                <span>${name}</span>
                <button class="btn btn-green text-xs" onclick="window.acceptGuest('${reqId}', '${userId}')">Accept</button>
            `;
            reqList.appendChild(div);
        }

        // Global function for the Accept button (needs to be on window)
        window.acceptGuest = async (reqId, userId) => {
            // 1. Mark user as allowed in database
            const userRef = doc(db, 'rooms', roomId, 'participants', userId);
            await updateDoc(userRef, { isGuestAllowed: true });
            
            // 2. Delete request
            await deleteDoc(doc(db, 'rooms', roomId, 'requests', reqId));
            
            showToast(`Accepted ${userId} as guest`);
        };

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.classList.add('show-toast');
            setTimeout(() => t.classList.remove('show-toast'), 3000);
        }

    </script>
</body>
</html>
